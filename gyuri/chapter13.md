# 13 웹페이지의 성능을 측정하는 다양한 방법

## 13.1 애플리케이션에서확인하기

### CRA

reportWebVitals.ts
누적 레이아웃 이동(CLS), 최초 입력 지연(FID), 최초 콘텐츠풀 페인트(FCP), 최대 콘텐츠 페인팅(LCP), 첫 바이트까지의 시간(TTFB)을 측정하는 용도로 사용

PerformanceObserver
웹페이지의 성능 측정을 위한 API

API를 제공하지 않는 브라우저에서는 web-vitals의 도움을 받아 성능을 측정하기 어렵다.

PerformanceObserver API를 통해 수집한 데이터를 sendBeacon API로 전송하거나, 구글 애널리틱스에 전송하는 등으로 분석할 수 있다.

> 💡 sendBeacon vs fetch

| **특징**           | **sendBeacon**                                 | **fetch**                                                 |
| ------------------ | ---------------------------------------------- | --------------------------------------------------------- |
| **목적**           | 페이지 언로드 시 데이터를 안정적으로 전송      | 다양한 HTTP 요청을 수행                                   |
| **전송 시점**      | 주로 페이지 언로드 시 사용                     | 언제든지 데이터 전송 가능                                 |
| **전송 안정성**    | 페이지가 닫혀도 데이터를 신뢰성 있게 전송      | 페이지가 닫히면 요청이 중단될 수 있음                     |
| **응답 처리**      | 응답을 처리하지 않음                           | 서버 응답을 처리 가능                                     |
| **구성 가능성**    | 설정 옵션이 제한적, 단순한 데이터 전송에 적합  | 요청 메서드, 헤더, 본문 등 다양한 옵션 설정 가능          |
| **비동기 처리**    | 비동기적, 전송 시작 후 페이지 언로드 계속 진행 | 비동기적, 프로미스 반환                                   |
| **사용 예제**      | 페이지 언로드 시 사용자 행동 데이터 전송       | 서버와의 다양한 상호작용, API 호출 등                     |
| **성능 최적화**    | 네트워크 성능에 미치는 영향 최소화             | 네트워크 성능에 미치는 영향 일반적                        |
| **에러 핸들링**    | 기본적인 에러 핸들링 제공                      | 네트워크 오류 및 서버 오류 처리 가능                      |
| **주요 사용 사례** | 사용자 행동 분석, 성능 로깅, 오류 보고 등      | 데이터 가져오기/보내기, 파일 업로드/다운로드, API 통신 등 |

### CNA

creat-next-app
NextWebVitalsMetric

```typescript
import { AppProps, NextWebVitalsMetric } from "next/app";

export function reportWebVitals(metric: NextWebVitalsMetric) {
  console.log(metric);
}

function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}

export default MyApp;
```

핵심 웹 지표 외에도 다음과 같은 Next.js에 특화된 사용자 지표 도 제공한다

- Next.js-hydration: 페이지가 서버 사이드에서 렌더링되어 하이드레이션하는 데 걸린 시간
- Next, js-route-change-to-render: 페이지가 경로를 변경한후 페이지를 렌더링을 시작하는 데 걸리는 시간
- Next.js-render: 경로 변경이 완료된 후 페이지를 렌더링하는 데 걸린 시간
- 모든 시간 단위는 밀리초 (ms)

![[Pasted image 20240527200909.png]]

> 💡뭘 확인해야 하지?
> 각각의 지표를 살펴보면서 서버 사이드 렌더링 시에 오래 걸리진 않는지, 페이지 전환 시에 호출되는 getServer-SideProps가 오래 걸리지 않는지 등을 살펴보면 좋다.

## 13.2 구글라이트하우스

웹 지표뿐만 아니라 접근성，PWA, SEO 등 웹 페이지를 둘러싼 다양한 요소들을 측정하고 점검할 수 있다.

> 💡 CLI: lighthouse라는 npm 라이브러리를 이용하면 CLI 명령어로 지표를 수집할 수 있다.
> 깃허브 액션 등 터미널만 제한적으로 사용할 수 있는 CI/CD 환경에서 사용하기에 적합

#### 1. 탐색 모드

페이지를 처음부터 다시 불러와서 페이지 로딩이 끝날 때까지 각각의 지표를 수집

**성능**
최초 콘텐츠풀 페인트(FCP), 최대 콘텐츠풀 페인트(LCP), 누적 레이아웃 이동(CLS)

1. Time to Interactive: 페이지에서 사용자가 완전히 상호작용(인터랙션)할 수 있을 때까지 걸리는 시간
   최초 콘텐츠풀 페인트로 측정되는 페이지 내 콘텐츠가 표시되는 되는 시점
   보여지는 페이지 요소의 대부분에 이벤트 핸들러가 부착되는 시점
   페이지가 유저의 상호작용에 50ms 내로 응답하는 시점
   > TTI 3.8초 이내 좋음, 7.3초 이내 보통, 그 이후 개선 필요

메인 스레드가 하는 작업을 최소화하고 전체적인 자바스크립트 실행 속도를 높일 필요가 있다.

2. Speed Index: 페이지가 로드되는 동안 콘텐츠가 얼마나 빨리 시각적으로 표시되는지를 계산

   > 3.8초이내 좋음, 5.8초 이내 보통, 그 이후는 그림

3. Total Blocking Time: 메인 스레드에서 특정 시간 이상 실행되는 작업, 즉 긴 작업이 수행될 때마다 메인 스레드가 차단된 것으로 간주한다. 메인 스레드가 차단됐다고 표현하는 이유는 브라우저가 이렇게 길게 실행되는 작업 때문에 무언가 다른 작업을 수행할 수 없기 때문이다.

**접근성**
장애인 및 고령자 등 신체적으로 불편한 사람들이 일반적인 사용자와 동등하게 웹페이지를 이용할 수 있도록 보장하는 것

이러한 사용자를 배려하기 위해 HTML과 CSS등에 적절한 대안을 삽입하는 것

시각으로 보기 어려운 경우 -> 스크린 리더를 사용하여 웹페이지의 내용을 직접 듣는 것이 가능하다. 그림이나 사진의 경우 읽을 수 없으므로 적절한 대체 문자가 필요하다.
오디오나 비디오는 청각이 제한적인 경우를 위해 자막이 필요하다.
마우스를 사용할 수 없는 상황을 대비하기 위해 키보드만으로 모든 컨텐츠에 접근할 수 있어야 한다.

**권장사항**
보안，표준 모드，최신 라이브러리，소스 맵 등 다양한 요소들이 포함

- CSP가 XSS 공격에 효과적인지 확인
- XSS (Cross Site Scripting) : 삽입한 스크립트를 통해 공격하는 기법. 게시판에 스크립트를 작성하는 등임.
- CSP (Content Security Policy) : 웹사이트에서 호출할 수 있는 컨텐츠를 제한하는 정책. 이미지, 스타일, 스크립트와 같은 정적 스크립트 뿐만 아니라 주소, 도메인등의 정보도 포함된다.
- 감지된 JavaScript 라이브러리 : 페이지에서 감지되는 자바스크립트 라이브러리
- HTTPS 사용: HTTP 대신 보안이 더 강력한 HTTPS를 사용하는지 확인
- 페이지 로드 시 위치정보 권한 요청 방지하기: 사용자의 동의 없이 페이지 로드 시 사용자의 물리적 위치를 알 수 있는 메서드인 window.navigator.geolocation.getCurrentPosition(), window.navigator.geolocation .watchPosition()을 실행하는지 확인
- 페이지 로드 시 알림 권한 요청 방지하기: 반드시 사용자액션이 있을 때만 호출하는 것이 좋다. 알려진 보안 취약점이 있는 프런트엔드 자바스크립트 라이브러리를 사용하지 않음
- 사용자가 비밀번호 입력란에 붙여넣을 수 있도록 허용 : 비밀번호 입력란은 붙여넣기가 가능해야 한다.
- 이미지를 올바른 가로세로 비율로 표시: 이미지의 실제 크기와 표시되는 크기 사이의 비율이 일치하는지 확인
- 이미지가 적절한 해상도로 제공됨: 이미지를 선명하게 보일 수 있도록 크기에 맞는 해상도의 이미지를 제공
- 페이지에 HTML Doctype 있음: Doctype이 선언되지 않았다면 표준을 준수하지 않은 것으로 간 주돼 호환 모드로 렌더링하게 와는데 이는 불필요한 작업이다. 따라서 웹페이지 첫 번째 줄에 `<!D0CTYPE html〉`을 선언 해 이러한 호환 모드 실행을 막는 것이 좋다.
- 문자 집합을 제대로 정의함: `<head>` 의 최상단에 `<meta charset="utf-8"/>`를 삽입해 UTF-8로 인코딩됐다고 명시
- 지원 중단 API 사용하지 않기: 더 이상 지원하지 않는 API는 잠재적으로 보안 취약점이 될 수 있으므로 사용하지 않는 것 이 좋다.
- 콘솔에 로그된 브라우저 오류 없음 : 사용자에게 영향을 미치지 않을 수도 있지만 분명 웹페 이지에 문제가 있다는 사실에는 변함이 없다
- Chrome Devtools의 Issues 패널에 문제없음: 크롬 개발자 도구에는 문제(Issues)라는 탭이 있는데, 이 랩에는 웹페이지 에 대한 여러 가지 문제점을 알려준다. 여기에 기록된 문제가 있다면 확인해 조치하는 것이 좋다.
- font-display: optional을 사용하는 폰트가 미리 로드됨: 앞서 언급한 폰트를 불러오는 방법 중 하나로, 개발자가 원 하는 임의의 폰트를 보여줄 수도 있으면서 동시에 사용자에게 버벅거림 없는 렌더링을 보장할 수 있는 가장 효과적인 방 법이다.

**검색 엔진 최적화**
`robots.txt`가 유효한지，이미지와 링크에 설명 문자가 존재하는지，`<meta>`나 `〈title〉`등으로 페이지의 정보 를 빠르게 확인할 수 있는지 등을 확인

#### 2. 기간(TimeSpan) 모드

여기서 확인할 수 있는 지표들은 크게 성능과 권장사항으로，앞서 탐색 모드와 크게 다르지 않다. 대다수의 사용자가 빈번하게 수행할 것으로 예상되는 작업을 기간 모드로 측정하면 성능 최적화에 큰 도움을 얻을 수 있다.

**흔적**

- View Trace
  측정한 기간의 성능을 파악할 수 있다.
- Tree Map
- 트리맵은 페이지를 불러올 때 함께 로딩한 모든 리소스를 함께 모아서 볼 수 있는 곳
- 실제 불러온 데이터의 크기를 확인할수도 있다.
- 로딩한 리소스에서 사용하지 않은 바이트의 크기를 확인하는 것인데，이는 실제로 불러왔지만 사용되지 않은 리소스를 의미

**스냅샷**

- 스냅샷 모드는 탐색 모드와 매우 유사하지만 현재 페이지 상태를 기준으로 분석한다는 점이 다르다
- 현재 상태에서 검색엔진의 최적화，접근성，성능 등을 분석
- 페이지 특정 상태 를 기준으로 분석하고 싶다면 스냅샷 모드를 사용하면 된다

## 13.3 WebPageTest

WebPageTest는 무료 기능도 있지만 유료로 제공하는 분석 도구도 있을 만큼 웹사이트 성능을 분석할 수 있는 심도 있는 기능이 많다

- Site Performance: 웹사이트의 성능을 분석을 위한 도구
- Core Web Vitals: 웹사이트의 핵심 웹 지표를 확인하기 위한 도구
- Lighthouse: 구글 라이트하우스 도구
- Visual Comparison: 2개 이상의 사이트를 동시에 실행해 시간의 흐름에 따른 로딩 과정을 비교하는 도구
- Traceroute: 네트워크 경로를 확인하는 도구

**Opportunities & Experiments**

Is it Quick: 웹사이트가 충분히 빠른지를 평가한다.

- 최초 바이트까지의 시간(TTFB)이 짧은지
- 콘텐츠 렌더링이 즉각적으로 일어나는지
- 최대 콘텐츠풀 페인트(LCP) 시간이 합리적인지
  Is it Usable: 웹사이트의 사용성과 시각적인 요소를 확인한다.
- 콘텐츠 누적 이동(CLS)을 최소화하고 있는지
- 상호작용 을 빠르게 할 수 있는지
- 접근성 이슈가 있는지
- 클라이언트 사이드에서 과도하게 HTML을 많이 렌더링하는지
  Is it Resilient: 보안 취약성을 점검한다.
- 렌더링을 블로킹하는 제3자 라이브러리가 존재하는지
- 실질적인 위협이 되는 보안 위험 요소가 있는지
  Observed Metrics: 최초 바이트까지의 시간, 렌더링 시작에 소요되는 시간, 최초 콘텐츠풀 페인트 등 측정할 수 있는 다 양한 시간 지표에 대해 나타낸다.
  Individual Runs: 기본적으로 WebPageTest는 3번의 테스트를 돌려서 평균값을 보여준다.

https://www.webpagetest.org/result/240528_BiDcNC_93S/

## 13.4 크롬 개발자 도구

- 크롬 확장 프로그램으로 인해 성능 이슈를 파악하는 데 방해가 될 수 있으므로 시크릿 창으로 웹사이트 를 열자

### 13.4.1 성능통계

Page Load를 선택해 웹사이트 로딩 시작부터 끝까지를 확인하거나，혹은 Start Recording을 눌러서 원하는 액션을 수행하면서 웹사이트 성능을 측정할 수 있다

Throttling : 고의로 네트워크와 CPU 속도를 지연시키는 기능

### Insights

성능을 측정하는 기간 동안 발생한 이벤트 중 눈여겨봐야 할 내용을 시간의 흐름에 따라 모 아서 보여준다.

- 핵심 웹 지표: 핵심 웹 지표인 최초 콘텐츠풀 페인트(FCP), 최대 콘텐츠풀 페인트(LCP), 그리고 Dom Content Loaded 가 언제 일어났는지 보여준다. 최대 콘텐츠풀 페인트의 경우 마우스를 가져다 대면 어떤 요소가 최대 콘텐츠풀 페인트인지 확인할수 있다.

- Performance Measure: User Timing API1Q로 측정한 지표들을 확인할 수 있다. 만약 Next.js로 제작된 애플리케이션이 라면 01 API를 사용한 흔적110을 볼 수 있다.

- Long Task : Performance Insight의 Insights 탭에서 가장 주목해야 할 것 중 하나다. 이 작업은 메인 스레드에서 실행 되는 데 오랜 시간으로 분류된 긴 작업을 의미한다. 무슨 작업인지 확인하기 위해 먼저 Long task를 클릭해 보자.

### 메인 메뉴

- Layout Shifts 영역은 레이아웃 이동이 일어날 경우 기록된다. 이 시점에 실행된 스크립트를 살펴보면 무엇 이 누적 레이아웃 이동을 발생시키는지 확인할 수 있다.
- Network에서는 성능 측정 기간 동안 발생한 네트워크 요청을 모두 확인할 수 있다

Timing은 앞에서도 언급한 User Timing API, 측정하고 싶은 기록이 있다 면 다음과 같이 코드를 작성하면 된다.

```typescript
const mark = 'marA' window.performance.mark(mark) // 측정하고 싶은 작업을 시작

window.performance.measure(•여기에 적은 메시지가 Timings에 나타납니다.'，mark)
```

### 성능

요약 : 요약 탭에서는 측정 기간의 CPU, 네트워크 요청，스크린숏，메모리 점유율 등을 요약해서 볼 수 있다
네트워크 : 성능 측정 기간 동안에 발생한 모든 네트워크 요청을 확인할 수 있다.
파란색: HTML 보라색: CSS  
 노란색: 자바스크립트
초록색: 이미지
회색: 기타, 폰트, JSON
위에 있는 요청이 우선순위가 높은 요청

소요 시간과 기본 : 시간의 흐름에 따라 메인 스레드의 작업은 어떻게 이뤄졌 는지，또 자바스크립트 힙 영역은 어떻게 변화하는지 등을 확인할 수 있다

[# 🔍 크롬 개발자 도구 (F12) 활용법 💯 총정리](https://inpa.tistory.com/entry/%F0%9F%92%BB-%ED%81%AC%EB%A1%AC-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%8F%84%EA%B5%AC-F12-%F0%9F%94%8D-%ED%99%9C%EC%9A%A9%EB%B2%95-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC-Elements%ED%8E%B8)
