# 리액트 핵심 요소 깊게 살펴보기

## 1. JSX

왜? 사용하는가?
JSX의 설계 목적 은 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점 을 두고 있다.
조금 더 쉽게 이야기하자면JSX 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성해 두고，이 JSX를 트랜스파일이라는 과정을 거쳐 자바스크립트(ECMAScript)가 이해할 수 있는 코드로 변 경하는 것이 목표

### 1-1. JSX의 정의

> JSXElement, JSXAttributes, JSXChildren, JSXStrings 로 크게 구성되어 있다.

JSX는 어떻게 자바스크립트에서 변환될까?
JSX를 변환하는 `@babel/plugin- transform-react-jsx` 로 변환해보면 다음과 같은 특징을 알 수 있다.

- JSXElement를 첫 번째 인수로 선언해 요소를 정의한다.
- 옵셔널인 JSXChildren, JSXAttributes, JSXStrings는 이후 인수로 넘겨주어 처리한다.

이 특성을 이용하면 아래와 같이 리펙토링도 가능하다!

```typescript
// X props 여부에 따라 children 요소만 달라지는 경우
// 삼항연산자로 처리할 필요가 없다!

function TextOrHeading({ isHeading, children, PropsWithChildren<{isHeading: boolean }>) {
    return isHeading ? (
    <hl className="text">{children}</hl>
    ):(
    <span className="text">{children}</span> )
    }

// JSX가 변환되는 특성을 활용한다면 다음과 같이 간결하게 처리할 수 있다.
import { createElement } from 'react'

function TextOrHeading({ isHeading, children, }): PropsWithChildren<{isHeading: boolean }> {
    return createElement(
        isHeading ? 'hl' : 'span1',
        { className: 'text' },
        children, )
    }
```

## 2. 가상 DOM과 리액트 파이버

### 가상 DOM

가상 DOM은 말 그대로 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM을 의미한다. 가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다. (여기서 말히는 리액트는 정확히 이야기하면 package, json에 있는 react가 아닌 `react-dom`을 의미한다.) 이렇게 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 된다면 실제로는 여러 번 발 생했을 렌더 링 과정을 최소화할 수 있고 브라우저와 개발자의 부담을 덜 수 있다.

### 브라우저 랜더링 과정

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다.
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고 사용자 눈에 보이는 노드만 방문한다. 즉, display: none과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서다.
6. 5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 장보를 이 노드에 적용한다. 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있다.
   - 레이아웃(layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
   - 페인팅(painting): 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정.

### 리액트 파이버

기존 렌더링 스택의 비효율성을 타파하기 위해 만들어졌다.
과거 리액트 리액트의 조정 알 고리즘은 스택 알고리즘으로 이뤄져 있었다

가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)

파이버는 파이버 재조정자(fiber reconciler)가 관리하는데, 이는 앞서 이야기한 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며， 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요 청하는 역할을 한다.

> 작업을 작은 단위로 분할하고 쪼갠 다음 우선순위를 매긴다.
> 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
> 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

위 작업들이 "비동기"로 일어난다.

리액트의 핵심 원칙은 UI를 문자 열，숫자，배열과 같은 값으로 관리한다는 것

### 리액트 파이버 트리

더블 버퍼링 : 보이지 않는 곳에서 그다음으로 그려야 할 그림을 미리 그린 다음，이것이 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법

파이버 트리는 사실 리액트 내부에서 두 개가 존재한다. 하나는 현재 모습을 담은 파이버 트리이고, 다른 하나는 작업 중인 상태 를 나타내는 workInProgress 트리다. 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버린다. 이러한 기술을 더블 버퍼링이라고 한다

리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이며，이 파이버는 리액트 아키텍처 내 부에서 비동기로 이뤄진다. 이러한 비동기 작업과 달리, 실제 브라우저 구조인 DOM에 반영하는 것은 동기 적으로 일어나야 하고，또 처리하는 작업이 많아 화면에 불완전하게 표시될 수 있는 가능성이 높으므로 이러 한 작업을 가상에서，즉 메모리상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.

리액트와 리액트 네이티브의 렌더러가 서로 다르다 하더라도 내부적으로 파이버를 통해서 조정되는 과정은 동일하기 때문에 동일한 재조정자를 사용할 수 있게된다.

## 3. 클래스형 컴포넌트와 함수형 컴포넌트

### 클래스형 컴포넌트

기본적으로 클래스형 컴포넌트를 만들려면 클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends해야 한다. (React.Component, React.PureComponent)

### 클래스형 컴포넌트 생명주기 메서드

- 마운트(mount): 컴포넌트가 마운팅(생성)되는 시점
- 업데이트(update): 이미 생성된 컴포넌트의 내용이 변경(업데이트)
- 되는 시점 언마운트(unmount): 컴포넌트가 더 이상 존재하지 않는 시점

- render() : 내부에서 state를 직접 업데이트하는 this.setstate를 호출해서는 안 된다.
- componentDidMount() : 컴포넌트가 마운트되고 준비되는 즉시 실행된다.
- componentDidUpdate() : 컴포넌트 업데이트가 일어난 이후 바로 실행된다.
- componentWillUnmount() : 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출, API 호출을 취소하거나，setinterval, setTimeout으로 생성된 타이머를 지우는 등의 작업을 하는 데 유용
- shouldComponentUpdate() : state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶을 때
- getSnapShotBeforeUpdate() : componentWillUpdate()를 대체할 수 있는 메서드, DOM이 업데이트되기 직전에 호출, 윈도우 크기를 조절하거나 스크롤 위치를 조정하는 등의 작업을 처리하는 데 유용 (클래스 컴포넌트만 가능)
- componentDidCatch() : 에러 상황에서 실행되는 메서드 (클래스 컴포넌트만 가능), componentDidCatch는 개발 모드와 프로덕션 모드에서 다르게 작동한다.
- getDerivedStateFromError() : 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드 (클래스 컴포넌트만 가능)

### 클래스형 컴포넌트의 한계

- 데이터의 흐름을 추적하기 어렵다
- 애플리케이션 내부 로직의 재사용이 어렵다
- 기능이 많아질수록 컴포넌트의 크기가 커진다
- 클래스는 함수에 비해 상대적으로 어렵다 (this 같은 것)

### 함수형 컴포넌트

render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요도 없으며，state는 객체가 아닌 각각의 원시값으로 관리되어 훨씬 사용하기가 편해졌다.

### 클래스형 vs 함수형

클래스형 컴포넌트의 생명주기 메서드가 함수형 컴포넌트에서는 존재하지 않는다

why?

- 함수형: 함수형 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수
- 클래스형: 클래스형 컴포넌트는 render 메서드가 있는 React.Component를 상속 받아 구현하는 자바스크립트 클래스

## 4. 랜더링은 어떻게 일어나는가?

브라우저에서 랜더링 : HTMl과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정.

리액트에서의 랜더링 : 리액트에서의 렌더링이란 리액트 애플리케이션 트 리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 네를 구 성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미

### 리액트 랜더링 프로세스

리액트의 재조정 (Reconciliation)

렌더링 프로세스가 실행되면서 이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집한 다음，리액트의 새 로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다.

### 랜더와 커밋

- 렌더 단계(Render Phase) : 컴포넌트를 렌더링하고 변경 사항을 계산하 는 모든 작업. type, props, key, 이 세 가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크 해둔다

- 커밋 단계(Commit Phase) : 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주 는 과정 (componentDidMount, componentDidUpdate, useLayoutEffect)

리액트 개발 도구(React Dev Tools)로 렌더링 과정을 캡처할 수 있다.

컴포넌트를 렌더링하는 작업은 별도로 렌더링을 피하기 위한 조치가 돼 있지 않는 한 하위 모든 컴포넌트 에 영향을 미친다. 그리고 부모가 변경됐다면 props가 변경됐는지와 상관없이 무조건 자식 컴포넌트도 리렌더링된다.

memoization한다면?

렌더 단계에서 컴포넌트 비교를 거쳤지만 memo로 선언한 덕분에 props가 변경되지 않으면 렌더링이 생략되므로 커밋 단계도 생략된 것.

## 5. 컴포넌트와 함수의 무거운 연산을 기억해두는 메모이제이션

> useMemo, useCallback, React.memo

메모이제이션은 언제 사용하는 것이 좋을까? (확률 게임 같다는 느낌을 받았다.)

### 1. 필요한 곳에만 메모이제이션 추가하자

> 요약: 상황에 따라 다르지만 계산 비용이 저장 비용보다 높을 경우에만 메모이제이션을 사용한다.

이전 결과를 캐시로 저장해 더 나은 성능을 위해 메모리에 차례대로 점유한다.
메모이제이션으로 인한 성능 개선이 랜덜이 보다 낫지 안다면 안하는게 더 낫다.

애플리케이션을 어느정도 만든 후, 개발자 도구나 useEffect를 사용해 실제로 어떻게 랜더링이 일어나고 있는지 확인하고 필요하 곳에만 최적화를 하는 것이 옳다.

Q: 오프스크린 컴포넌트의 메모리 해제?

섣부른 최적화 : premature optimization, premature memoization

### 2. 랜더링 과정의 비용느 비싸기 때문에 전부 메모이제이션 하자

컴포넌트 복잡성이 증가하는 사황에서는, 필요한 곳에만 최적화를 하기란 쉽지 않다. 그런 기조를 유지하기가 어렵다.

어차피 리액트는 이전 랜더링 결과를 다음 랜더링 결과와 구별하기 위해 저장해둔다.
따라서 잘못된 memo로 지불하는 비용은 props에 얕은 비교가 발생할 때 뿐이다.

memo를 하지 않았을 때 발생하는 비용

- 랜더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두가지 모두가 자식 컴포넌트에서 반복적으로 일어남
- 리액트가 구 트리와 신규 트리를 비교

memo를 하지 않았을 때 치뤄야할 잠재적 비용이 memo를 했을 때 보다 더 크다.

useMemo, useCallback: 의존성 배열을 비교하여 필요에 따라 값을 재계산함

참조한 값이 만약에 useEffect의 의존성 배열에 쓰인다면? 변경된 참조로 인해 영향을 미칠 것이다.

컴포넌트 자신의 리랜더링 뿐만 아니라 이를 사용하는 쪽에서도 변하지 않는 고정된 값을 사용할 수 있다는 믿음을 줄 수 있다.

### 3. 결론

리액트를 깊이 이해하고 싶고 시간적 여유가 있다. -> 필요한 곳에만 메모이제이션 추가

현업에서 사용중이고 시간적 여유가 없다. -> 의심스러운 곳에 다 사용하자

- 일반적으로 props에 대한 얕은 비교를 수행하는 것 보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교한느 작업이 더 무겁고 비싸다. 조금이라도 로직이 들어간 경우 메모이제이션이 성능 향에 도움을 줄 가능성이 크다.
