# 리액트 핵심 요소 깊게 살펴보기

## 1. JSX

## 2. 가상 DOM과 리액트 파이버

## 3. 클래스형 컴포넌트와 함수형 컴포넌트

## 4. 랜더링은 어떻게 일어나는가?

브라우저에서 랜더링 : HTMl과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정.

## 5. 컴포넌트와 함수의 무거운 연산을 기억해두는 메모이제이션

> useMemo, useCallback, React.memo

메모이제이션은 언제 사용하는 것이 좋을까? (확률 게임 같다는 느낌을 받았다.)

### 1. 필요한 곳에만 메모이제이션 추가하자

> 요약: 상황에 따라 다르지만 계산 비용이 저장 비용보다 높을 경우에만 메모이제이션을 사용한다.

이전 결과를 캐시로 저장해 더 나은 성능을 위해 메모리에 차례대로 점유한다.
메모이제이션으로 인한 성능 개선이 랜덜이 보다 낫지 안다면 안하는게 더 낫다.

애플리케이션을 어느정도 만든 후, 개발자 도구나 useEffect를 사용해 실제로 어떻게 랜더링이 일어나고 있는지 확인하고 필요하 곳에만 최적화를 하는 것이 옳다.

(P. 184)
Q: 오프스크린 컴포넌트의 메모리 해제는 어떤 경우일가요..?

섣부른 최적화 : premature optimization, premature memoization

### 2. 랜더링 과정의 비용느 비싸기 때문에 전부 메모이제이션 하자

컴포넌트 복잡성이 증가하는 사황에서는, 필요한 곳에만 최적화를 하기란 쉽지 않다. 그런 기조를 유지하기가 어렵다.

어차피 리액트는 이전 랜더링 결과를 다음 랜더링 결과와 구별하기 위해 저장해둔다.
따라서 잘못된 memo로 지불하는 비용은 props에 얕은 비교가 발생할 때 뿐이다.

memo를 하지 않았을 때 발생하는 비용

- 랜더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두가지 모두가 자식 컴포넌트에서 반복적으로 일어남
- 리액트가 구 트리와 신규 트리를 비교

memo를 하지 않았을 때 치뤄야할 잠재적 비용이 memo를 했을 때 보다 더 크다.

useMemo, useCallback: 의존성 배열을 비교하여 필요에 따라 값을 재계산함

참조한 값이 만약에 useEffect의 의존성 배열에 쓰인다면? 변경된 참조로 인해 영향을 미칠 것이다.

컴포넌트 자신의 리랜더링 뿐만 아니라 이를 사용하는 쪽에서도 변하지 않는 고정된 값을 사용할 수 있다는 믿음을 줄 수 있다.

### 3. 결론

리액트를 깊이 이해하고 싶고 시간적 여유가 있다. -> 필요한 곳에만 메모이제이션 추가
현업에서 사용중이고 시간적 여유가 없다. -> 의심스러운 곳에 다 사용하자

- 일반적으로 props에 대한 얕은 비교를 수행하는 것 보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교한느 작업이 더 무겁고 비싸다. 조금이라도 로직이 들어간 경우 메모이제이션이 성능 향에 도움을 줄 가능성이 크다.
