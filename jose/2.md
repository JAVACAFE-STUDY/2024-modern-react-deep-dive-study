## 1️⃣JSX
- Javascript Syntax eXtension의 약자이다. 자바스크립트 확장문법이라고 보면됨.
- 공식적인 자바스크립트 문법은 아니라는 사실!!
```javascript
//이게
<div>
  Hello <b>react</b>
</div>
//이코드로 변환됨.
React.createElement("div", null, "Hello ", React.createElement("b", null, "react"));
```

### 🐶JSXElement
JSXElement가 되기 위해서 다음과 같은 형태 중 하나여야 한다.
- JSXOpeningElement
  - JSX를 구성하는 가장 기본요소로 HTML의 요소와 비슷한 역할
  - <JSXElement JSXAttributes(optional)>
- JSXClosingElement
  - JSXOpeningElement가 종료됐음을 알리는 요소로 JSXOpeningElement와 쌍으로 쓰이는 요소
  - <JSXElement />
- JSXSelfClosingElement
  - 요소가 시작되고 스스로 종료되는 형태를 의미로 내부적으로 자식을 포함할 수 없다.
  - <JSXElement JSXAttributes(optional) />
- JSXFragment
  - 아무런 요소도 없음.
  - <>JSXChildren(optional)</>

JSXElementName은 JSXElement의 요소 이름으로 쓸 수 있는 것을 의미한다.

### 🐶JSXAttributes
JSXAttributes은 JSXElement에 부여할 수 있는 속성을 의미한다.

### 🐶JSXChildren
JSXChildren은 JSXElement의 자식 값을 나타낸다. JSX로 부모와 자식 관계를 나타낼 수 있다.
```javascript
function Example1(){
  return <Component><>{'{}'}</></Component>
}
  
// 리액트에서 렌더링 시 'foo' 라는 문자열이 생성
function Example2(){
  return <Component>{(() => 'foo')()}</Component>
}
```
### 🐶JSXStrings
HTML에서 사용가능한 모든 문자열.
- 큰 따옴표로 구성된 문자열과 작은 따옴표로 구성된 문자열 혹은 JSXText.
- 다만 \로 시작하는 이스케이프 문자 형태소는 사용이 불가능하니 주의해야함.
  - ex>> let text = " \ "
### 주의점
JSX 내부에 자바스크립트 문법이 너무 뒤섞이면 가독성을 해친다. JSX 내부에 자바스크립트 문법을 최소화할 방법을 고민하는것도 중요할듯.
<br/>
<br/>
<br/>

## 2️⃣가상 DOM과 리액트 파이버
### 🐶DOM과 브라우저 렌더링 과정
1. 브라우저가 사용자 요청 주소를 방문해 HTML 문서를 받음.
2. 브라우저 렌더링 엔진이 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만듬.
3. CSS 파일을 다운.
4. CSS도 다운로드, 파싱해 CSS 트리 (CSSOM) 구성함.
5. DOM 노드 순회한다.
6. display: none; 과 같이 사용자 화면에 보이지 않는 요소는 작업하지않음
7. 눈에 보이는 노드만 찾아서 해당 노드에 대한 CSSOM 정보 찾고 적용
    > 레이아웃 (layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 나타내야 하는지 계산하는 과정

    > 페인팅 (painting): 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

### 🐶가상 DOM의 탄생 배경
브라우저는 아래의 경우일때 레이아웃 계산과 페인팅 작업을 진행한다.

- 자바스크립트에 의한 노드 추가 또는 삭제.
- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
- HTML 요소의 레이아웃에 변경을 발생시키는 width/height, margin, padding, border등의 스타일 변경
> 따라서 위의 조건은 비용이 많이들며 성능에 악영향을 끼칠 수 있다.

가상 DOM은 위와는 다르게 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트(react-dom)가 실제 변경에 대한 준비가 됐을 때 실제 브라우저의 DOM에 반영
### 🐶리액트 파이버
- 리액트 파이버의 개념
  - 리액트에서 관리하는 평범한 자바스크립트 객체
  - 파이버 재조정자가 관리
  - 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하고, 둘 사이 차이가 있으면 변경에 관련된 정보를 가진 파이버 기준으로 화면에 렌더링 요청
- 파이버의 역할
  - 작업을 작은 단위로 분할, 쪼갠 다음 우선순위를 매김
  - 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있음.
  - 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우 폐기.
  - 비동기적으로 동작.
### 🐶파이버의 작업순서
1. 리액트가 beginWork()함수를 실행하여 파이버 작업을 한다. 더이상 자식이 없는 파이버를 만날때까지 트리형식으로 쭈욱 작업한다.
2. 1번 작업이 마무리되면 completeWork()함수를 실행해 파이버 작업을 완료함.
3. 형제가 있다면 형제로 작업이 넘어간다.
4. 2, 3번에 일이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.


## 3️⃣클래스형 컴포넌트와 함수형 컴포넌트
### 🐶함수형 컴포넌트 vs 클래스형 컴포넌트

- 생명주기 메서드의 부재
  - 생명주기 메서드는 React.Component에서 오기 때문에 함수형 컴포넌트에서 사용할 수 없다.
  - 함수형 컴포넌트는 useEffect를 통해 생명주기 메서드인 componentDidMount, componentDidUpdate, componentWillUnmount를 비슷하게 구현
  - 그러나 useEffect는 생명주기를 위한 훅이 아니라 컴포넌트의 state를 활용해 동기적으로 부수 효과를 만드는 메커니즘
    > 여기서 개인적으로 내가 훅을 완전히 잘못이해하고 있었다고 생각함. vue.js를 경험해본 입장에서 리액트 훅을 vue.js에 빗대어 이해하곤 했는데, vue.js의 옵션들의
라이프 사이클 옵션들과 리액트 훅을 비교하여 이해했었음.

- this에 바인딩 된 props를 사용하는 클래스형 컴포넌트와 다르게, 함수형 컴포넌트는 props를 인수로 받는다.

- 렌더링 된 값
  - this와 다르게 props는 인수로 받기 때문에 컴포넌트는 그 값을 변경할 수 없고 해당 값을 그대로 사용한다.
  - 함수형 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 Props와 state를 기준으로 렌더링하는 반면, 클래스형 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링한다는 특징을 가짐.

<br/>
<br/>
<br/>

## 4️⃣렌더링은 어떻게 일어나는가?
### 🐶리액트 렌더링의 개념
리액트에서의 렌더링은 리액트의 모든 컴포넌트들이 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 지 계산하는 일련의 과정

### 🐶리액트의 렌더링이 발생하는 시나리오
1. 최초 렌더링: 사용자가 처음 애플리케이션에 진입하면 당연히 렌더링해야 할 결과물이 필요하다. 리액트는 브라우저에게 정보를 제공하기 위해 최초 렌더링을 수행한다.
2. 리렌더링: 최초 렌더링 이후 발생하는 모든 렌더링을 의미한다.
	- 함수형 컴포넌트의 useState()의 두 번째 배열 요소인 setter가 실행되는 경우, state를 업데이트 하는 함수
	- 함수형 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우
	- 컴포넌트의 key props가 변경되는 경우: 리액트에서 key는 명시적으로 선언돼 있지 않더라도 모든 컴포넌트에서 사용할 수 있는 특수한 props이다.
	- props가 변경되는 경우: 부모로부터 전달받은 값인 props가 달라지면 이를 사용하는 자식 컴포넌트에서도 변경이 필요하므로 리렌더링이 일어난다.
	- 부모 컴포넌트가 렌더링 경우: 당연한 얘기지만 부모 컴포넌트가 리렌더링된다면 자식 컴포넌트는 당연히 리렌더링이 일어난다.
### 🐶리액트의 렌더링 프로세스
렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다. 그 이후 렌더링 결과물을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다.
리액트의 렌더링은 렌더 단계와 커밋 단계라는 총 두 단계로 분리되어 실행된다는 것이다.

### 🐶렌더와 커밋
- 렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다. 렌더링 프로세스에서 컴포넌트를 실행해 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계이다.
- 다음 커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정이다.
  > 잠깐! Reconcile하는 과정도 존재함. 이전에 렌더링된 실제 DOM 트리와 새로 렌더링할 React 엘리먼트를 비교하여 변경점을 적용한다. 참고로 렌더와 커밋 중간에 실행된다.

- 리액트는 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다. 렌더 단계에서 변경 사항이 감지되지 않는다면, 커밋 단계는 생략될 수 있다.
리액트의 렌더링은 항상 동기식으로 작동했다. 렌더링 프로세스 특징을 자세히 본다면 동기식으로 진행하는 것이 맞다. 순서가 보장되지 않는 비동기식으로 렌더링을 처리한다면 User에게 혼란을 야기할 수 있다.
  > B.U.T React18
동시성 렌더링을 지원
상대적으로 빠르게 렌더링 할 수 있는 컴포넌트를 먼저 렌더링하는 등, 의도된 우선순위로 컴포넌트를 렌더링해 최적화 하는 기법

### 🐶메모이제이션
리액트 메모이제이션의 개념
useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위한 훅이다.

useMemo, useCallback
- 값을 얻어낼 때 마다 복잡한 로직을 사용해야 할 때
- 렌더링 할 때 마다 비용 소모가 클 때
- props로 넘어갈 때 참조 투명성을 유지하기 위해 사용하는 것이 좋다.

React.memo()
- 컴포넌트가 리액트 트리에서 중위-상위 레벨에 해당하는 경우
- props가 단순하고 자주 바뀌지 않을 경우
- props가 복잡한 Object일 때

## 5️⃣컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

### 🐶주장 1: 꼭 필요한 곳에만 메모이제이션을 추가해두자.

- 가벼운 작업 자체는 메모이제이션 하기 좋다.
- 메모이제이션도 비용이 든다. 어디 저장했다가 다시 가져오는, 두번의 비용이 든다.
- 메모이제이션은 항상 어느정도의 트레이드 오프가 있다.

### 🐶주장 2: 렌더링 과정은 비싸므로 모조리 메모이제이션 해버리자.

- 우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐인 것.

- 반면 memo를 하지 않아 발생할 수 있는 문제는 아래와 같다.
  - 렌더링을 함으로써 발생하는 비용
  - 컴포넌트 내부의 복잡한 로직의 재실행
  - 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
  - 리액트가 구 트리와 신규 트리를 비교

### 🐶나의 생각
리액트를 사용함에 있어서 뜨거운 감자같은 논쟁거리를 직접보니 재밌었고, 그럼에도 "꼭 필요한 곳에만 메모이제이션을 추가하는게 맞지않을까?"라는 생각을 했었다. 이번 기회에 회사코드에 useCallback과 useMemo, memo를 적절하게 사용하고있는지 돌이켜보고 싶었다.

한편으로 리액트 19버전부터는 메모이제이션 훅, 함수들이 사라진다고한다. vue.js처럼 리액트가 이를 알아서 처리해주는 방향으로 바뀐다.