# **Chapter-02**

리액트 핵심 요소 깊게 살펴보기

## Table of contents
- [2.1 JSX란](#21-jsx란)
- [2.2 가상 DOM과 리액트 파이버](#22-가상-dom과-리액트-파이버)
- [2.3 클래스 컴포넌트와 함수 컴포넌트](#23-클래스-컴포넌트와-함수-컴포넌트)
- [2.4 렌더링은 어떻게 일어나는가?](#24-렌더링은-어떻게-일어나는가)
- [2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션](#25-컴포넌트와-함수의-무거운-연산을-기억해-두는-메모이제이션)

---

## **2.1 JSX란?**
JSX는 자바스크립트 표준 코드가 아니며, 트랜스파일러를 거쳐야 자바스크립트 런타임이 이해할 수 있는 의미 있는 자바스크립트 코드로 변환된다. 
JSX의 설계 목적은 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점을 둔다. 
요약하자면, JSX는 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는 데 많은 도움을 주는 새로운 문법이라고 볼 수 있다. 



### JSX의 정의
- JSXElement: JSX를 구성하는 가장 기본 요소로, HTML의 요소(Element)와 비슷한 역할
- JSXAttribute: JSXElement 에 부여할 수 있는 속성을 의미
- JSXChildren: JSXElement의 자식 값을 나타냄. JSX는 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있으며, 그 자식이 JSXChildren 임
- JSXStrings: 

### JSX 예제

```jsx
const ComponentA = <A>안녕하세요</A>

const ComponentD = <A required />
```

### JSX는 어떻게 자바스크립트에서 변환될까?
@babel/plugin-transform-react-jsx 플러그인은 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환함


### 정리
적어도 리액트 내부에서 JSX가 어떻게 변환되는지, 어떤 결과물을 만들어내는지 알아두면 리액트 활용에 도움이 됨 

---

## **2.2 가상 DOM과 리액트 파이버**

### 2.1 DOM과 브라우저 렌더링 과정
1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다
2. 브라우저의 렌더링 엔진은 HTML 을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고, 사용자 눈에 보이는 노드만 방문한다. 즉, display: none과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서다.
6. 5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고, 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있다.
  - 레이아웃: 각 노드가 브라우저의 화면의 어느 좌표에 나타나야 하는지 계산하는 과정
  - 페인팅: 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정 


### 2.2 가상 DOM의 탄생 배경
렌더링이 완료된 이후에도 사용자의 인터랙션으로 웹페이지가 변경되는 상황은 빈번하게 발생하는데, 가상 DOM은 웹페이지가 표시해야 할 DOM을 메모리에 저장하고, 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다. 이렇게 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한번 거치게 되면 실제로 여러 번 발생했을 렌더링 과정을 최소화할 수 있고, 브라우저와 개발자의 부담을 덜 수 있음


### 2.3 리액트 파이버
리액트 파이버는 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 함.


### 정리
가상 DOM과 리액트의 핵심은 브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아니라, 바로 값으로 UI를 표현하는 것이다. 화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고, 이러한 흐름을 효율적으로 관리하기 위한 매커니즘이 바로 리액트의 핵심이다.

---

## **2.3 클래스 컴포넌트와 함수 컴포넌트**

### 클래스 컴포넌트와 함수형 컴포넌트

```jsx
class Welcome extends React.Component {
  constructor(props) {
    super(props);
    this.state = { greeting: 'Hello' };
  }

  render() {
    return <h1>{this.state.greeting}, {this.props.name}</h1>;
  }
}

ReactDOM.render(
  <Welcome name="Jane" />,
  document.getElementById('root')
);
```

### 함수 컴포넌트

```jsx
function Welcome(props) {
  const [greeting, setGreeting] = React.useState('Hello');

  return <h1>{greeting}, {props.name}</h1>;
}

ReactDOM.render(
  <Welcome name="Jane" />,
  document.getElementById('root')
);
```


## **2.4 렌더링은 어떻게 일어나는가?**
리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

### 리액트의 렌더링이 일어나는 이유
- 최초 렌더링
- 리렌더링

### 리액트의 렌더링 프로세스


### 렌더와 커밋



## **2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션**

### 주장1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

### 주장2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자
