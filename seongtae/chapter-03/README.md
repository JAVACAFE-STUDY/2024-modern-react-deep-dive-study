# **Chapter-03**

리액트 훅 깊게 살펴보기

함수형과 클래스형 컴포넌트에는 많은 차이가 있기 때문에 리액트로 웹서비스를 만드는 개발자라면, 훅이 어떻게 동작 하는지 이해할 필요가 있다

## Table of contents
- [3.1 리액트의 모든 훅 파헤치기](#31-리액트의-모든-훅-파헤치기)
- [2.2 가상 DOM과 리액트 파이버](#22-가상-dom과-리액트-파이버)

---

## **3.1 리액트의 모든 훅 파헤치기**

### useState
useState는 함수형 컴포넌트 내부에 서 상태를 정의하고，이 상태를 관리할 수 있게 해주는 훅이다.

useState는 자바스크립트의 특징 중 하나인 클로저에 의존해 구현돼 있을 것이라는 사실을 짐작해 볼 수 있는데, 클로저를 사용함으로써 외부에 해당 값을 노출시키지 않고 오직 리액트에서만 쓸 수 있었고，함수형 컴포넌트가 매번 실행되더라도 useState에서 이전의 값을 정확하게 꺼내 쓸 수 있게 됐다.

#### 게으른 최적화
게으른 최적화에 대해 리액트에서는 무거운 연산이 요구될 때 사용하라고 한다. 즉, localstorage나 sessionstorage에 대한 접근, map, filter, find 등과 같은 배열에 대한 접근, 혹은 초깃값 계산을 위해 함수 호출이 필요할 때와 같이 무거운 연산을 포함해 실행 비용이 많이 드는 경우에 게으른 초기화를 사용하는 것이 좋다.

---

### useEffect
`useEffect`는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘인데, 이 부수 효과가 ‘언제’ 일어나는지보다 어떤 상태값과 함께 실행되는지 살펴보는 것이 중요하다.

`useEffect`는 자바스크립트의 proxy나 데이터 바인딩, 옵저버 같은 특별한 기능을 통해 값의 변화를 관찰하는 것이 아니라 렌더링할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른 경우 하나라도 있으면 부수 효과를 실행하는 평범한 함수라 볼 수 있다. 따라서 `useEffect`는 `state와` `props`의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있다.

#### useEffect를 사용할 때 주의할 점
- eslint-disable시에 react-hooks/exhaustive-deps 주석은 최대한 자제하라.
- useEffect의 첫 번째 인수에 함수명을 부여하라.
- 거대한 useEffect를 만들지 마라.
- 불필요한 외부 함수를 만들지 마라.

---

### useMemo
useMemo는 비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 이 저장된 값을 반환하는 훅. 
- 리액트에서 최적화를 떠올릴 때 가장 먼저 언급되는 훅

---

### useCallback
`useMemo`가 값을 기억했다면, `useCallback`은 인수로 넘겨받은 콜백 자체를 기억한다. 쉽게 말해 `useCallback`은 특정 함수를 새로 만들지 않고 다시 재사용한다는 의미이다. 

값의 메모이제이션을 위해 useMemo를 사용했다면, 함수의 메모이제이션을 위해 사용하는 것이 useCallback이다. useCallback의 첫 번째 인수로 함수를, 두 번째 인수로 의존성 배열을 집어 넣으면 useMemo와 마찬가지로 의존성 배열이 변경되지 않는 한 함수를 재생성하지 않는다.


### useRef
useRef는 useState와 동일하게 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장한다는 공통점이 있지만 useState와 구별되는 큰 차이점 두 가지를 가지고 있다. 

- useRef는 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다. 
- useRef는 그 값이 변하더라도 렌더링을 발생시키지 않는다. 

useRef를 사용할 수 있는 유용한 경우는 렌더링을 발생시키지 않고 원하는 상태값을 저장할 수 있다는 특징을 활용해 useState의 이전 값을 저장하는 usePrevious() 같은 훅을 구현할 때다. 개발자가 원하는 시점의 값을 렌더링에 영향을 미치지 않고 보관해 두고 싶다면 useRef를 사용하는 것이 좋다.

### useContext
리액트 애플리케이션은 기본적으로 부모 컴포넌트와 자식 컴포넌트로 이뤄진 트리 구조를 갖고 있기 때문에 부모가 가지고 있는 데이터를 자식에서도 사용하고 싶다면 props로 데이터를 넘겨주는 것이 일반적이지만 전달해야 하는 데이터가 있는 컴포넌트와 전달받아야 하는 컴포넌트의 거리가 멀어질수록 코드는 복잡해진다.

useContext는 상위 컴포넌트에서 만들어진 Context를 함수형 컴포넌트에서 사용할 수 있도록 만들어진 훅이다. useContext를 사용하면 상위 컴포넌트 어딘가에서 선언된 `<Context.Provider />`에서 제공한 값을 사용할 수 있게 된다. 만약 여러 개의 Provider가 있다면 가장 가까운 Provider의 값을 가져오게 된다.

일부 리액트 개발자들이 콘텍스트와 useContext를 상태 관리를 위한 리액트의 API로 오해하고 있다는 것이다. 엄밀히 따지면 콘텍스트는 상태를 주입해 주는 API다. 상태 관리 라이브러리가 되기 위해서는 최소한 두 가지 조건을 만족해야 한다.

1. 어떠한 상태를 기반으로 다른 상태를 만들어 낼 수 있어야 한다.
2. 필요에 따라 이러한 상태 변화를 최적화할 수 있어야 한다.

---

## **3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?**
리액트에서는 재사용할 수 있는 로직을 관리할 수 있는 두 가지 방법이 있다. 
바로 사용자 정의 훅(custom hook)과 고차 컴포넌트(higher order component)다.

### 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?
사용자 정의 훅과 고차 컴포넌트 모두 리액트 코드에서 어떠한 로직을 공통화해 별도로 관리할 수 있다는 특징이 있다. 애플리케이션 전반에 필요한 중복된 로직을 별도로 분리해 컴포넌트의 크기를 줄이고 가독성을 향상시키는 데 도움을 줄 수 있다. 

#### 사용자 정의 훅이 필요한 경우
만약 단순한 로직이고 리액트의 내장 훅으로 충분히 처리할 수 있다면, 사용자 정의 훅을 사용하는 것이 좋다. 사용자 정의 훅은 렌더링에 영향을 미치지 않으며, 반환된 값에 따라 사용자가 원하는 대로 작동하므로 개발자가 훅을 유연하게 활용할 수 있다.

#### 고차 컴포넌트를 사용해야 하는 경우
로그인 여부를 확인하거나 특정 에러에 대한 처리 등과 같이 컴포넌트의 렌더링을 변경해야 하는 상황에는 고차 컴포넌트를 사용하는 것이 적합하다. 이러한 경우에는 컴포넌트를 감싸는 형태로 고차 컴포넌트를 만들어 필요한 로직을 주입할 수 있다.
