# 🎁 렌더링은 어떻게 일어나는가?

## 🧸 브라우저에서의 렌더링 vs 리액트의 렌더링

### 📍 브라우저에서의 렌더링

- HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정

### 📍 리액트의 렌더링: 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정

- 시간과 리소스를 소비해 수행되는 과정
- 이 비용은 모두 웹 애플리케이션을 방문하는 사용자에게 청구됨
- 시간이 길어지고 복잡해질수록 유저의 사용자 경험을 저해함
  => 따라서 렌더링 과정을 최소한으로 줄여야 함 ✨

## 🧸 리액트의 렌더링이란?

리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미함

👀 컴포넌트가 props와 state와 같은 상태값을 가지고 있지 않다면, 해당 컴포넌트가 반환하는 JSX 값에 기반해 렌더링이 일어나게 됨

## 🧸 렌더링이 발생하는 시나리오

1. 최초 렌더링
2. 리렌더링: 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의미함
   - 클래스형 컴포넌트
     - setState가 실행되는 경우
     - forceUpdate가 실행되는 경우
       - shouldComponentUpdate는 무시하고 건너뜀 (하위 모든 컴포넌트에 적용)
       - render 내에서 forceUpdate()가 사용되면 무한루프에 빠지므로 사용하지 말기
   - 함수형 컴포넌트
     - useState()의 두 번째 배열 요소인 setter가 실행되는 경우
     - useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우
   - 컴포넌트의 key props가 변경되는 경우

##### 🤔 useState 등으로 관리되지 않는 단순한 변수는?

- 변경된다 하더라도 리렌더링을 발생시키지 않아 변경된 값을 렌더링된 DOM에서 확인할 수 없음

## 🧸 리액트의 렌더링 프로세스

1. 렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾음

2. 클래스형 컴포넌트의 경우 클래스 내부의 render() 함수 실행
   함수형 컴포넌트의 경우 FunctionComponent() 그 자체를 호출한 뒤에 그 결과물을 저장함

   - 렌더링 결과물은 JSX 문법으로 구성돼 있고, 이것이 자바스크립트로 컴파일되면서 React.createElement()를 호출하는 구문으로 변환됨

   - createElement는 브라우저의 UI 구조를 설명할 수 있는 일반적인 자바스크립트 객체를 반환함

   - 렌더링 결과물 예시

     ```json
     {type: TestComponent, props: {a: 35, b: "yceffort", children: "안녕하세요"}}
     ```

3. 재조정 과정: 각 컴포넌트의 렌더링 결과물을 수집 -> 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집함
4. 재조정 과정이 모두 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 됨

## 🧸 렌더와 커밋

#### 📍 렌더 (Render)

- 렌더링 프로세스에서 컴포넌트를 실행해(render() 또는 return) 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계
- 비교하는 것: type, props, key
  - 이 세 가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해 둠
- 사용자에게 노출되지 않는 모든 비동기 작업을 수행함
- 파이버의 작업: 우선순위를 지정하거나 중지시키거나 버리는 등의 작업 진행

#### 📍 커밋 (Commit)

- 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정
- 이 단계가 끝나야 비로소 브라우저의 렌더링이 발생함
- 파이버: commitWork()가 실행됨. 동기식. 중단될 수 없음.

---

1. 리액트가 먼저 DOM을 커밋 단계에서 업데이트한다면 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트함
2. 그 다음 생명주기 개념이 있는 클래스형 컴포넌트에서는 componentDidMount, componentDidUpdate 메서드를 호출하고, 함수형 컴포넌트에서는 useLayoutEffect 훅을 호출함

#### ⚡️ 중요한 사실

- 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아님
- 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면 생략될 수 있음

## 🧸 동기식 렌더링과 비동기식 렌더링

#### 📍 동기식 렌더링

- 리액트의 렌더링은 항상 동기식으로 작동했음
- 렌더링 과정이 길어질수록 애플리케이션의 성능 저하로 이어지고, 결과적으로 그 시간만큼 브라우저의 다른 작업을 지연시킬 가능성이 있음

#### 📍 비동기식 렌더링 (동시성 렌더링)

- 리액트 18에서 도입
- 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링
- 렌더 단계가 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나, 필요하다면 중단하더나 재시작하거나, 경우에 따라서는 포기할 수도 있음

## 🧸 메모이제이션

- 별도로 렌더링을 피하기 위한 조치가 돼 있지 않은 한 하위 모든 컴포넌트에 영향을 미침
- 부모가 변경됐다면 props가 변경됐는지와 상관없이 무조건 자식 컴포넌트도 리렌더링됨
  - memo를 사용하면 리렌더링을 피할 수 있음
