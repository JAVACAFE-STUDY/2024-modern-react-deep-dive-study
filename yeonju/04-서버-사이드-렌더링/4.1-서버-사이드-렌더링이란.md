# 🕵️ 서버 사이드 렌더링

## 1️⃣ 싱글 페이지 애플리케이션의 세상

### ✏️ 싱글 페이지 애플리케이션(Single Page Application: SPA)이란?

- 자바스크립트를 활용해 **하나의 페이지에서만 렌더링을 수행**
- 렌더링과 라우팅에 필요한 대부분의 기능을 `서버`가 아닌 `브라우저의 자바스크립트`에 의존하는 방식
- 최초에 첫 페이지에서 데이터를 모두 불러온 이후에는, 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저의 `history.pushState`와 `history.replaceState`로 이뤄짐

> 즉, **페이지를 불러온 이후에는 서버에서 HTML을 내려받지 않고 하나의 페이지에서 모든 작업을 처리**하므로 `싱글 페이지 애플리케이션`이라고 함

#### 👀 SPA로 만들어진 사이트의 HTML 코드를 보면 `<body />` 내부에 아무런 내용이 없음!

> 사이트 렌더링에 필요한 `<body />` 내부의 내용을 **모두 자바스크립트 코드로 삽입**한 이후에 렌더링하기 때문

- 페이지 전환 시에 새로운 HTML 페이지를 요청하는 거 ❌
- 자바스크립트에서 다음 페이지의 렌더링에 필요한 정보만 HTTP 요청 등으로 가져온 다음, 그 결과를 바탕으로 `<body />` 내부에 DOM을 추가, 수정, 삭제하는 방법으로 페이지가 전환됨
- 즉, 최초에 서버에서 최소한의 데이터를 불러온 이후부터는 **이미 가지고 있는 자바스크립트 리소스와 브라우저 API를 기반으로 모든 작동이 이루어짐**

<br />

### ✏️ SPA의 장단점

#### 👍🏻 장점

- 한 번 로딩된 이후에는 서버를 거쳐 필요한 리소스를 받아올 일이 적어지기 때문에 사용자에게 훌륭한 UI/UX를 제공한다는 장점이 있음

#### 👎🏻 단점

- 최초에 로딩해야 할 자바스크립트 리소스가 커짐

<br />

### ✏️ 전통적인 방식의 애플리케이션과 SPA의 작동 비교

#### 1. 전통적인 방식의 애플리케이션 (\*서버 사이드에서 작동)

- **페이지 전환이 발생할 때마다 새롭게 페이지를 요청**함
- HTML 페이지를 다운로드해 파싱하는 작업을 거침
- 페이지 전환이 발생할 때마다 페이지를 처음부터 새로 그려야 해서 일부 사용자는 부자연스러운 모습을 보게 됨
- ex) 네이버 홈 화면 -> 네이버 스포츠 화면

#### 2. SPA

- 페이지 전환에 **필요한 일부 영역만 다시 그림** -> 훨씬 더 매끄러운 UI
- ex) Gmail

<br />

### ✏️ js 위주의 SPA 방식이 등장하게 된 배경

1. 과거 PHP나 JSP를 기반으로 만들었을 땐, 렌더링이 서버사이드에서 이뤄짐
   - js는 사용자에게 추가적인 경험을 주기 위한 보조적인 수단으로 사용
2. js가 서서히 다양한 작업을 수행하면서 js를 모듈화하는 방안이 점차 논의되기 시작했음
   - 그에 따라 등장한 것이 CommonJS와 AMD
   - js 모듈화의 결실, 사용자 기기의 성능 향상, 인터넷 속도의 발전 등으로 js에서 할 수 있는 일이 점점 많아짐
3. 이러한 변화에 힘입어 2010년 경 Backbone.js와 AngularJS, Knockout.js 등이 등장
   - js 수준에서 MVx 프레임워크를 구현하기 시작함
   - js에서도 어느 정도 서버에서만 할 수 있는 복잡한 작업을 할 수 있음
   - 이때부터 js 역할과 규모가 점점 커짐
4. 이후 React, Vue, Angular 시대가 옴
   - 사용자에게 좀 더 멋진 UX를 제공할 수 있음
   - 좀 더 간편한 개발 경험
     - PHP 시절과 달리 자바스크립트만 잘 작성하면 되기 때문

<br />

### ✏️ JAM 스택의 등장

1. `JAM 스택`: JavaScript, API, MarkUp
   - SPA의 유행으로 인해 새롭게 생겨난 용어
2. `LAMP 스택`: Linux, Apache, MySQL, PHP/Python
   - 기존의 웹 개발
3. `MEAN 스택`: MongoDB, Express.js, AngularJS, Node.js
4. `MERN 스택`: MongoDB, Express.js, React, Node.js

<br />

### ✏️ 새로운 패러다임의 웹서비스를 향한 요구

- js 파싱을 위해 CPU를 소비하는 시간이 눈에 띄게 증가
  - 그만큼 js에서 처리해야 하는 코드의 절대적인 양이 증가
- 사용자의 기기와 인터넷 속도 등 웹 전반을 이루는 환경이 크게 개선됐음에도, 실제 사용자들이 느끼는 웹 애플리케이션의 로딩 속도는 5년 전이나 지금이나 크게 차이가 없거나 오히려 느림

<br />
<br />

## 2️⃣ 서버 사이드 렌더링(Server Side Rendering: SSR)이란?

- 최초에 사용자에게 보여줄 페이지를 **서버에서 렌더링해** 빠르게 사용자에게 화면을 제공하는 방식
- 싱글 페이지 애플리케이션의 태생적인 한계(속도 이슈)로 인해 다시금 떠오르는 방식

### ✏️ SSR의 장점

#### 1. 최초 페이지 진입이 비교적 빠르다

- 사용자가 최초 페이지에 진입했을 때 페이지에 유의미한 정보가 그려지는 시간(First Contentful Paint: FCP)이 더 빨라질 수 있음
- 특히, 화면 렌더링이 **HTTP 요청에 의존적**이거나 **렌더링해야 할 HTML의 크기가 커진다면** 상대적으로 SSR이 더 빠를 수 있음
  - 일반적으로 서버에서 HTTP 요청을 수행하는 것이 더 빠르기 때문
  - 서버에서 HTML을 문자열로 미리 그려서 내려주는 시간 << 클라이언트에서 기존 HTML에 삽입하는 시간
  - but, 서버가 사용자를 감당하지 못하고, 리소스를 확보하기 어렵다면 오히려 SPA보다 느려질 수 있음

#### 2. 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다

##### 👀 검색 엔진이 사이트에서 필요한 정보를 가져가는 과정

1. 검색 엔진 로봇(머신)이 페이지에 진입함
2. 페이지가 HTML 정보를 제공해 로봇이 이 HTML을 다운로드. (자바스크립트 파일 실행은 X ⭐️)
3. 다운로드한 HTML 페이지 내부의 오픈 그래프(Open Graph)나 메타(meta) 태그 정보를 기반으로 페이지의 검색(공유) 정보를 가져오고 이를 바탕으로 검색 엔진에 저장함

> - 브라우저: 해당 페이지를 사용자에게 HTML이나 각종 정보로 제공하기 위해 -> js를 실행해야 함
> - 로봇: 페이지를 보는 것이 아닌 페이지의 정적인 정보를 가져오는 것이 목적 -> js를 다운하거나 실행할 필요 ❌

- SPA: 대부분의 작동과 메타 정보가 js에 의존 -> 따로 조치를 취하지 않는다면 불이익
- SSR: 최초의 렌더링 작업이 서버에서 일어나기 때문에, 검색 엔진에 제공할 정보를 서버에서 가공해서 HTML 응답으로 제공할 수 있음 -> 검색 엔진 최적화 대응에 유리

#### 3. 누적 레이아웃 이동(CLS)이 적다

> 누적 레이아웃 이동(Cumulative Layout Shift: CLS)이란?
>
> - 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥거리는 것과 같은 부정적인 사용자 경험

- SPA: 페이지 콘텐츠가 API 요청에 의존하고, API 요청의 응답 속도가 제각각이며, 이를 처리해두지 않는다면 CLS 문제 발생
- SSR: 이러한 요청이 완전히 완료된 이후에 완성된 페이지를 제공하므로 이러한 문제에서 비교적 자유로움

#### 그러나,,,

- react의 useEffect는 클라이언트에서 컴포넌트가 마운트된 이후에 실행되므로 SPA, SSR 모두 문제의 소지가 있음
- SSR에서는 모든 요청이 완료되기 전까지 페이지가 렌더링되지 않을 것이므로 최초 페이지 다운로드가 굉장히 느려질 수 있음
- 이를 리액트 18에서 등장한 스트림으로 인해 해결될 수도 있음.

#### 4. 사용자의 디바이스 성능에 비교적 자유롭다

- **부담을 서버에 나눌 수 있으므로** 사용자의 디바이스 성능으로부터 조금 더 자유로워질 수 있음
- 절대적인 것은 아님 (ex. 인터넷 속도가 느릴 경우)

#### 5. 보안에 좀 더 안전하다

- JAM 스택을 채택한 프로젝트의 공통된 문제점: 애프리케이션의 모든 활동이 브라우저에 노출된다는 것
- SSR: 인증 혹은 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 보안 위협을 피할 수 있음

<br />

### ✏️ SSR의 단점

#### 1. 소스코드를 작성할 때 항상 서버를 고려해야 한다

- 소스코드 전반에 걸쳐 server 환경에 대한 고려가 필요함
- 가장 큰 문제: 브라우저 전역 객체인 `window` 또는 `sessionStorage`와 같이 브라우저에만 있는 전역 객체 등
  - 소스코드나 사용 중인 라이브러리에서 `window`를 사용하고 있고, 이 코드가 만약 server에서 실행된다면 `window is not defined`라는 에러를 마주하게 됨
  - server에서도 실행될 가능성이 있는 코드라면 `window`에 대한 접근을 최소화해야 하고, `window` 사용이 불가피하다면 해당 코드가 서버 사이드에서 실행되지 않도록 처리해야 함
- 외부에 의존하고 있는 라이브러리가 server에 대한 고려가 돼 있지 않다면 다른 대안을 찾거나 클라이언트에서만 실행될 수 있도록 처리해야 함
  - client에서만 실행되는 코드가 많아질수록 SSR의 장점을 읽는 셈

#### 2. 적절한 서버가 구축돼 있어야 한다

> 서버를 구축하는 일이 쉬운 일은 아님

- 사용자의 요청에 따라 적절하게 대응할 수 있는 물리적인 가용량을 확보해야 함
- 예기치 않은 장애 상황에 대응할 수 있도록 복구 전략도 필요
- 요청을 분산시키고, 프로세스가 예기치 못하게 다운될 때를 대비해 PM2와 같은 프로세스 매니저의 도움도 필요함

#### 3. 서비스 지연에 따른 문제

- SPA: '로딩 중'과 같이 진행 중임을 적절히 안내 가능 -> 사용자가 기다릴 여지가 있음
- SSR: 최초 렌더링시 서비스 지연이 발생한다면 큰 문제가 됨 -> 어떠한 정보도 제공할 수 없기 때문!

<br />
<br />

## 3️⃣ SPA와 SSR을 모두 알아야 하는 이유

### ✏️ SPA와 SSR의 차이는 '웹페이지 렌더링의 책임을 어디에 두느냐'다.

- SPA: 사용자에게 제공되는 `자바스크립트 번들`에서 렌더링을 담당 -> **사용자 기기의 성능에 영향**을 받음
- SSR: 렌더링에 필요한 작업을 모두 `서버`에서 수행함 -> 서버에서 제공하기 때문에 **비교적 안정적**인 렌더링이 가능

### ✏️ SSR 역시 만능이 아니다.

- 잘못된 웹페이지 설계는 오히려 성능을 해칠 뿐만 아니라 눈에 띄는 성능 개선도 얻지 못할 수 있음
- 서버 + 클라이언트 **두 군데로 관리 포인트만 늘어나기만 하는 역효과**를 낳을 수도 있음
- 우선순위에 따라 SPA가 더 효율적일 수도 있음

### ✏️ SPA vs SSR

> 두 방법론 모두 상황에 따라 유효한 방법임. 모두 장단점이 있으며 어느 하나가 완벽하다고 볼 수 없음

1. 가장 뛰어난 SPA > 가장 뛰어난 MPA

   - ex. gmail
     - 최초 페이지 진입 시에 보여줘야 할 정보만 최적화해 요청해서 렌더링함
     - 이미지와 같은 중요성이 떨어지는 리소스는 게으른 로딩으로 렌더링에 방해되지 않도록 처리함
     - 코드 분할(사용자에게 필요한 코드만 나눠서 번들링하는 기법)도 칼같이 지켜서 불필요한 자바스크립트 리소스의 다운로드 및 실행을 방지함
     - 라우팅이 발생하면 변경이 필요한 HTML 영역만 교체해 사용자의 피로감을 최소화함

2. 평균적인 SPA < 평균적인 MPA
   - MPA: 매번 서버에 렌더링 요청을 하고, 서버는 안정적인 리소스를 기반으로 매 요청마다 비슷한 성능의 렌더링을 수행할 것
   - SPA: 렌더링과 라우팅에 최적화가 돼 있지 않다면 사용자 기기에 따라 성능이 들쑥날쑥하고, 적절한 성능 최적화도 돼 있지 않을 가능성이 높음
   - 심지어 최근에는 MPA에서 발생하는 라우팅으로 인한 문제를 해결하기 위한 다양한 API가 브라우저에 추가되고 있음
     - `페인트 홀딩(Paint Holding)`
       - 같은 출처에서 라우팅이 일어날 경우 화면을 잠깐 하얗게 띄우는 대신 이전 페이지의 모습을 잠깐 보여주는 기법
     - `back forward cache(bfcache)`
       - 브라우저 앞으로 가기, 뒤로가기 실행 시 캐시된 페이지를 보여주는 기법
     - `Shared Element Transitions`
       - 페이지 라우팅이 일어났을 때 두 페이지에 동일 요소가 있다면 해당 콘텍스트를 유지해 부드럽게 전환되게 하는 기법

### ✏️ 현대의 SSR

> 현대의 SSR은 지금까지 LAMP 스택에서 표현했던 SSR 방식과는 조금 다름

- 기존 LAMP 스택:
  - 모든 페이지 빌드를 서버에서 렌더링해 **초기 페이지 진입이 빠름**
  - **이후 라우팅**이 발생할 때도 마찬가지 -> **느림**
- 요즘의 SSR 방식
  - 초기 페이지 진입 **빠름** + 이후 라우팅도 **빠름**
  - ex. Next.js, Remix 등
