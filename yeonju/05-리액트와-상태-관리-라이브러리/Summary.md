### 상태란?

- 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미
- URL도 상태값임. 브라우저에서 관리되고 있는 상태값!

  - ex. `https://www.airbnb.co.kr/rooms/123?adults=2` => 상태값: roomId=123, adults=2

### tearing

- 하나의 상태에 따라 서로 다른 결과물을 사용자에게 보여주는 현상

### 🎁 단방향 데이터 흐름의 장단점

- **장점**
  - 데이터의 흐름은 모두 액션이라는 한 방향(단방향)으로 줄어들므 로 데이터의 흐름을 추적하기 쉽고 코드를 이해하기가 한결 수월해짐
- **단점**
  - 사용자의 입력에 따라(여기에서는 사용자의 클릭에 따라) 데이터를 갱신하고 화면을 어떻게 업데이트해야 하는지도 코드로 작성해야 하므로 코드의 양이 많아지고 개발자도 수고로워짐
- 리액트는 대표적인 단방향 데이터 바인딩을 기반으로 한 라이브러리

### 🎁 양방향 데이터 흐름의 장단점

- **장점**
  - 모델과 뷰가 서로를 자동으로 업데이트하기 때문에 개발자가 수동으로 동기화할 필요가 없어 개발이 더 빠르고 간편해짐
  - 사용자 인터페이스와 데이터 모델 간의 연동이 직관적이고 즉각적으로 반영되므로 복잡한 상호작용을 쉽게 구현할 수 있음
- **단점**
  - 데이터 흐름을 추적하기 어렵고 디버깅이 복잡해질 수 있음. 데이터가 여러 컴포넌트를 거쳐 양방향으로 흐르면서 어디서 데이터가 변경되었는지 파악하기 어려움
  - 뷰와 모델이 밀접하게 결합되어 있어서, 애플리케이션 규모가 커지면 유지 보수와 확장성이 떨어질 수 있음

### 리액트 상태 관리의 역사

- 단순히 UI를 만들기 위한 라이브러리였음
- 웹 애플리케이션이 비대해짐에 따라 상태를 추적하기 어려워짐 (양방향 데이터 바인딩이어서)
- MVC 패턴 -> 양방향 데이터 바인딩의 문제를 해결하고자 단방향 데이터 흐름인 Flux 패턴 등장

### Elm

- 웹페이지를 선언적으로 작성하기 위한 언어
- 핵심: model, view, update
- Flux와 마찬가지로 데이터의 흐름을 세 가지로 분류하고, 이를 단방향으로 강제해 웹 애플리케이션 의 상태를 안정적으로 관리하고자 노력

### Redux

- Flux 구조 + Elm 아키텍처 도입
- 단점

  - 하고자 하는 일에 비에 boiler plate가 너무 많음
  - RTK(Redux Toolkit)을 도입하면 스토어 및 리듀서 생성의 보일러플레이트 코드를 줄일 수 있음

### Atomic

- 핵심 개념
  - React의 상태 관리를 컴포넌트 트리에 분산시키고자 하는 것
  - atom은 context처럼 상태를 가져올 수 있지만 동시에 코드 분할을 더 세분화할 수 있음

### Context API, useContext

- Context API는 상태 관리가 아닌 주입을 도와주는 기능
- 렌더링을 막아주는 기능 또한 존재하지 않으니 사용할 때 주의

### useState, useReducer

- 두 훅 모두 지역 상태 관리를 위해 만들어짐
- 훅을 사용할 때마다 컴포넌트별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가질 수밖에 없음
- 두 컴포넌트에서 같은 값을 사용하려면?
  - 상태를 컴포넌트 밖으로 한 단계 끌어올려야 함

### 상태 관리 Tool 비교

- Recoil, Jotai
  - atomic
  - Context과 Provider, 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는 데 초점을 맞추고 있음
- Zustand
  - flux
  - 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리하는 라이브러리
  - 하나의 큰 스토어는 Context가 아니라 스토어가 가지는 클로저를 기반으로 생성되며, 이 스토어의 상태가 변경되면 이 상태를 구독하고 있는 컴포넌트에 전파해 리렌더링을 알리는 방식

### Recoil, Jotai, Zustand, Valtio

- Redux, MobX 같은 라이브러리와의 차이점
  - 훅을 활용해 작은 크기의 상태를 효율적으로 관리함
    - peerDependencies로 리액트 16.8 버전 이상을 요구
  - 리액트와의 연동을 전제로 작동해 별도로 다른 라이브러리를 설치하지 않아도 됨
- 장점
  - 기존 상태 관리 라이브러리의 아쉬운 점으로 지적받던 전역 상태 관리 패러다임에서 벗어나 개발자가 원하는 만큼의 상태를 지역적으로 관리하는 것을 가능하게 만들어줌
  - 훅을 지원함으로써 함수형 컴포넌트에서 손쉽게 사용할 수 있음

### Recoil

- Recoil의 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장됨
- atom: 상태를 나타내는 Recoil의 최소 상태 단위
- useRecoilValue: atom의 값을 읽어오는 훅
- useRecoilState: 값을 가져오고 변경할 수 있는 훅
- 비동기 작업을 지원하기 위한 API도 지원
  - useRecoilStateLoadable, waitForAll, waitForAny, waitForAllSettled

### Jotai

- Recoil의 atom 모델에 영감을 받아 만들어진 상태 관리 라이브러리
- 상향식(bottom-up) 접근법을 취하고 있음
- 메모이제이션이나 최적화를 거치지 않아도 리렌더링이 발생되지 않도록 설계돼 있음
- Recoil과는 다르게, atom 하나만으로 상태를 만들 수도, 또 이에 파생된 상태를 만들 수도 있음
- store에 atom 객체 그 자체를 키로 활용해 값을 저장
  - WeakMap이라고 하는, js에서 객체만을 키로 가질 수 있는 독특한 방식의 Map을 활용해 별도의 key를 받지 않아도 스토어에 값을 저장할 수 있음

### Zustand

- flux 기반
- 리덕스에 영감을 받아 만들어짐
- 최소 단위의 상태를 관리하는 것이 아니라 하나의 스토어를 중앙 집중형으로 활용해 관리
- export하는 유일한 함수 및 변수는 바로 createStore임
  - 또한, 그 어떤 것도 import하고 있지 않음. => 프레임워크와는 별개로 완전히 독립적으로 구성돼 있다는 것 => js환경에서도 사용할 수 있음
- 장점
  - 많은 코드를 작성하지 않아도 빠르게 스토어를 만들고 사용할 수 있음
  - Bundlephobia 기준 2.9kB밖에 안됨
  - ts기반으로 작성돼 있기 때문에 별도로 `@types`를 설치하거나 임의로 작성된 `d.ts`에 대한 우려 없이 ts를 자연스럽게 쓸 수 있음
  - 미들웨어를 지원함
    - persist: 스토어 데이터를 영구히 보존할 수 있음
    - immer: 복잡한 객체를 관리하기 쉽게 도와주는
