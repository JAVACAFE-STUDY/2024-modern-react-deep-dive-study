# 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

## 웹사이트와 성능

- 사용자가 웹사이트에 접속했을 때 공통적으로 기대하는 사항
  1. 웹사이트를 방문한 목적을 손쉽게 달성할 수 있어야 함
  2. 첫 번째 목적을 달성하는 데 걸리는 시간이 짧아야 함
  3. 웹사이트에서 개인정보가 누출되는 등의 사고 없이 보안이 철저해야 함

## 핵심 웹 지표(Core Web Vital)란?

- 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어
- 핵심 웹 지표
  - 최대 콘텐츠풀 페인트(LCP: Largest Contentful Paint)
  - 최초 입력 지연(FID: First Input Delay)
  - 누적 레이아웃 이동(CLS: Cumulative Layout Shift)
- 핵심까지는 아니지만, 특정 문제를 진단하는 데 사용될 수 있는 지표
  - 최초 바이트까지의 시간(TTFB: Time To First Byte)
  - 최초 콘텐츠풀 시간(FCP: First Contentful Paint)

## 최대 콘텐츠풀 페인트(LCP: Largest Content Paint)

### 정의

- 페이지가 처음으로 로드를 시작한 시점부터 **뷰포트 내부**에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간
- 뷰포트 내부에서 '큰 이미지와 텍스트'
  - `<img>`
  - `<svg>` 내부의 `<image>`
  - poster 속성을 사용하는 `<video>`
  - url()을 통해 불러온 배경 이미지가 있는 요소
  - 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
    - 이 블록 레벨 요소에는 `<p>`, `<div>` 등이 포함됨

### 의미

- 단순히 사용자에게 있어 로딩이란 일단 뷰포트 영역에 보이는 부분을 기 준으로 할 것이므로 뷰포트에 메인 콘텐츠가 화면에 완전히 전달되는 속도를 기준으로 한다면 사용자는 페이 지가 로딩이 완료됐다고 체감하는 시간과 매우 비슷하게 측정할 수 있을 것
- DOMContentLoaded를 기준으로 측정되는 것이 아님
  - DOMContentLoaded?
    - HTML 문서를 완전히 불러오고 파싱했을 때 발생하는 이벤트로，페이지의 document를 대상으로 일어나며 단 한 번만 호출
    - 이 이벤트가 발생했다고 해서 사용자 또한 페 이지가 로딩됐다고 인식할 것이라 기대하기에는 무리가 있음
    - 왜냐하면 DOMContentLoaded 이벤트는 ‘스타일시트，이미지，하위 프레임의 로딩은 기다리지 않는다’는 제한이 있기 때문

### 기준 점수

- ~ 2.5 sec : GOOD
- 2.5 sec ~ 4.0 sec : NEEDS IMPROVEMENT
- 4.0 sec ~ : POOR

### 개선 방안

- 텍스트는 언제나 옳다
  - 뷰포트 최대 영역, 즉 최대 콘텐츠풀 페인트 예상 영역에 이미지가 아닌 문자열을 넣는 것
- 이미지는 `<img>`, `<video>` 태그를 통해 불러오기 => 프리로드 스캐너에 의해 조기 발견되기 때문!!
- 이미지 무손실 압축
- `loading=lazy`: 최대 콘텐츠풀 콘텐츠의 이미지는 중요하지 않은 리소스로 분류하면 안됨. 이는 그저 로딩 속도만 늦출 뿐 지표 점수에는 도움이 되지 않음!!
- fadein과 같은 각종 애니메이션
- 클라이언트에서 빌드하지 말 것
  - 서버에서 빌드해온 HTML을 프리로드 스캐너가 바로 읽어서 최대 콘텐츠풀 페인트로 빠르게 가져가는 것이 좋음
- 최대 콘텐츠풀 리소스는 직접 호스팅
  - 가능하다면 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋다.

## 최초 입력 지연(FID: First Input Delay)

### 정의

- 화면이 최초에 그려지고 난 뒤, 사용자가 웹페이지에서 클릭 등 상호작용을 수행했을 때 메인 스레드가 이 이벤트에 대한 반응을 할 수 있을 때까지 걸리는 시간을 의미한다. 그리고 이 시간은 메인 스레드가 처리해야 하는 다른 작업이 많을수록 느려진다.
- 사용자가 페이지와 처음 상호 작용할 때부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간
  - ex: 링크 클릭 / 버튼 탭 / 사용자 지정 JavaScript 기반 컨트롤을 사용할 때
- 사용자가 얼마나 빠르게 웹페이지와의 상호작용에 대한 응답을 받을 수 있는지 측정하는 지표
- 모든 입력에 대해 측정하는 것이 아니며, 최초의 입력 하나에 대해서만 그 응답 지연이 얼마나 걸리는지 판단함

### 웹사이트 내부의 이벤트 반응이 늦어지는 이유?

- 해당 입력을 처리해야 하는 브라우저의 메인 스레드가 바쁘기 때문

  - 대규모 렌더링이 일어나고 있거나, 대규모 자바스크립트 파일을 분석하고 실행하는 등 다른 작업을 처리하는 데 리소스를 할애하고 있기 때문
  - 메인 스레드가 바쁜 경우, 자바스크립트 실행 환경은 '싱글 스레드'이기 때문에 자바스크립트가 이벤트 리스너와 같은 다른 작업을 실행할 수 없어 지연이 발생함
  - 즉, 이벤트가 발생하는 시점에 최대한 메인 스레드가 다른 작업을 처리할 수 있도록 여유를 만들어 둬야 사용자에게 빠른 반응성을 보장할 수 있다.

### 최초 입력에 해당되는 것

- ✅ 클릭, 터치, 타이핑 등 사용자의 개별 입력 작업
- ❌ 스크롤, 핀치 투 줌은 애니메이션으로 분류

### RAIL: 구글이 사용자 경험을 4가지 분류해 정의해둔 것

- Response: 사용자의 입력에 대한 반응 속도. 50ms 미만으로 이벤트를 처리할 것 => ✅ 최초 입력 지연은 R에 해당하는 응답에 초점을 맞추고 있음
- Animation: 애니메이션의 각 프레임을 10ms 이하로 생성할 것
- Idle: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
- Load: 5초 이내에 콘텐츠를 전달하고 인터랙션을 준비할 것

### 기준 점수

- ~ 100ms: GOOD
- 100ms ~ 300ms: NEEDS IMPROVEMENT
- 300ms ~ : POOR

### 개선 방안

- 실행에 오래 걸리는 긴 작업이 있다면 여러 개로 분리
  - 최초 로딩에 필요하지 않은 내용을 나중에 불러오기 (Suspense, lazy, dynamic 이용)
- 자바스크립트 코드 최소화
  - 현대의 번들링 도구들은 코드 번들링에 필요한 코드만 모아서 최종 프로덕션 자바스크립트 코드를 생성해주지만 필요없는 코드가 존재할 수도 있음
    - 크롬 개발자 도구의 커버리지로 확인해보기
  - 폴리필 확인
    - 인터넷 익스플로러 11에 없는 코드를 기준으로 하게 되면 폴리필의 크기가 기하급수적으로 커짐
    - 바벨 같은 도구를 사용하고 있다면 @babel/preset-env19를 사용해 애플리케이션 코드에서 사용하고 있는 내용만 폴리필에 담을 수 있음
    - Next.js의 SWC를 사용하고 있다면 이미 SWC 내부에 구현돼 있기 때문에 별도로 처리하지 않아도 될 것으로 보임
- 타사 자바스크립트 코드 실행의 지연
  - 타사 스크립트는 대부분 웹페이지 로드에 중요한 자원이 아니므로〈script〉의 async와 defer를 이용 해 지연 불러오기를 하는 것이 좋음
  - 가능하다면 `async`, 더 가능하다면 `defer`로 지연
    - `async`: 해당 스크립트를 다른 리소스와 함께 병렬로 다운 -> 다운 즉시 실행
    - `defer`: 해당 스크립트를 다른 리소스와 함께 병렬로 다운 -> 페이지가 완전히 로딩된 이후에 맨 마지막에 실행
  - 만약 광고와 같이 실제 사용자의 뷰포트 위치에 따라 불러와야 하는 컴포넌트라면 `Intersection Observer`를 이용해 뷰포트에 들어오는 시점에 불러오는 것이 좋음

## 누적 레이아웃 이동(CLS: Cumulative Layout Shift)

### 정의

- 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것

### 의미

- 최초 렌더링 이후에 실행되는 useEffect가 많을수록，그리고 이 useEffect가 렌더링에 영향을 미칠수록 이 누적 레이아웃 이동에 좋지 못한 점수를 받을 가능성이 커진다.
- 가시적인 콘텐츠에 영향을 미쳐야 하기 때문에 뷰포트 내부의 요소에 대해서만 측정
- 요소가 추가됐다 하더라도 다른 요소의 시작 위치에 영향 을 미치지 않았다면 레이아웃 이동으로 간주되지 않음
- 클라이언트에서 미리 노출이 예상되는 부분을 HTML로 자리 잡아 두는 것이 누적 레이 아웃 지표에 큰 도움이 됨

### 기준 점수

- ~ 0.1: GOOD
- 0.1 ~ 0.25: NEEDS IMPROVEMENT
- 0.25 ~ : POOR

### 개선 방안

- 삽입이 예상되는 요소를 위한 추가적인 공간 확보
  - 스켈레톤 UI
  - useEffect 사용이 불가피하다면 useLayoutEffect 흑을 사용해 보는 것 또한 검토
    - 누적 레이아웃 이동을 막으려다가 다른 모든 작업에 악 영향을 끼칠 수 있으므로 신중하게 선택해야 함
  - SSR을 통해 클라이언트에 HTML을 미리 제공
  - 뷰포트에 동적인 콘텐츠를 제공할지를 신중하게 고민
- 폰트 로딩 최적화
  - FOUT(flash of unstyled text): 대체 기본 폰트로 보이고 있다가 뒤늦게 폰트가 적용되는 현상
  - FOIT(flash of invisible text): 기본 폰트도 없어서 텍스트가 없는 채로 있다 가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상
  - `<link>`의 `preload` 사용: 페이지에서 즉시 필요로 하는 리소스를 명시하는 기능
  - `font-family`의 `optional` 사용
    - 최대한 중요한 폰트의 다운로드를 우선순위에 밀어넣고，이 우선순위를 활용했음에도 빠르게 로딩하는 데 실패했다면 다음을 기약하고 기본 폰트를 노출
- 적절한 이미지 크기 설정
  - width: 100%; height: auto;와 함께 width, height를 원하는 비율로 지정하면 브라우저가 이미지를 로딩하기 전에 적절한 가로세로 비율을 계 산해 이미지가 표시되는 만큼 면적을 할당해 둔다
  - 만약 사용자 뷰포트 너비에 맞춰 다른 이미지를 제공하고 경우. 즉 반응형 이미지를 사용하고 싶다면 srcset 속성24을 사용하는 것이 좋다.

## 최초 바이트까지의 시간(TTFB: Time To First Byte)

- 페이지를 요청했을 때 요청이 완전히 완료되는 데 걸리는 시간을 측정하는 것이 아니라 최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정하는 지표
  - 600ms 이상 걸릴 경우 개선이 필요한 것으로 간주
  - SSR에서 주의깊게 봐야 할 지표

## 최초 콘텐츠풀 페인트(FCP: First Contentful Paint)

- 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠 의 일부가 화면에 렌더링될 때까지의 시간을 측정
- 웹사이트에 접속한 순간부 터 페이지에 뭐라도 뜨기 시작한 시점까지의 시간을 의미
  - 텍스트, 이미지, svg 등

### 기준 점수

- ~ 1.8sec: GOOD
- 1.8sec ~ 3.0sec: NEEDS IMPROVEMENT
- 3.0sec ~: POOR

### 개선 방안

- 최초 바이트까지의 시간(TTFB)을 개선
- 렌더링을 가로막는 리소스 최소화
- Above the Fold(최초에 스크롤을 굳이 하지 않아도 보이는 영역)에 대한 최적화
- 페이지 리다이렉트 최소화
- DOM 크기 최소화
  - 전체 D0M 노드는 1500개 미만으로，깊이는 32단계 정도까지만, 그리고 부모 노드는 자식 노드를 60개 정도만 가지고 있어야 함
