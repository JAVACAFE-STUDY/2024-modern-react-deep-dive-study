<aside>
💡 [11장 Next.js13과 리액트 18]

## app 디렉터리의 등장

### 기존 Next.js 약점으로 레이아웃 설정이 있음

- 페이지가 각각 독립되어 있다보니 공통된 레이아웃 설정이 어려움이 있음
- 그나마 설정 가능한 곳은 `app.tsx` 에 가능했지만 한곳에서 설정하다보니 많은 어려움이 있었음
- 그래서 등장한 것이 app 레이아웃! 두둥!

### 라우팅

- 라우팅 정의하는 법
    - 기존과 동일하게 파일 시스템 기반
    - 약간의 차이점은
        - `파일명은 제외`
        - 폴더명까지만 주소로 변환
- 폴더 기반이기에 내부 파일의 몇가지 예약어 파일이 존재


    | 예약어 파일 | 설명 | 전역 파일 |
    | --- | --- | --- |
    | layout.js | - 레이아웃 파일
    - 해당 폴더 및 하위 폴더의 레이아웃에 영향을 미치는 파일
    - 유연하게 구성할 수 있음
    - _document.jsx에서 Next.js에서 제공하던 어색한 태그가 아닌 HTML 기반으로의 코드 구성 | - 루트에 가능
    - 루트에 설정 시 이전 버전의 _document.jsx, _app.jsx와 같은 기능 처럼 사용 가능 |
    | page.js | - 기존의 페이지 파일과 동일
    - props
      - params: 옵셔널, 동적 라우트 파라미터
      - searchParms: url Query 파라미터, layout에서는 제공하지 않음, layout은 페이지 탐색 중 리렌더링을 하지 않음  |  |
    | error.js | - 해당 라우팅 영역에서 공통 에러 컴포넌트
    - 클라이언트 컴포넌트이어야 함(’user client’)
    - 같은 수준의 컴포넌트에서는 사용되지 않음 | app/global-error.js |
    | not-found.js | - 404페이지 | app/not-found.js |
    | loading.js | - Suspense 기반으로 컴포넌트를 불러오는 중임을 나타낼 때
    - ‘use client’도 가능 |  |
    | route.js | - Next.js RestAPI 기능
    - 이전에는 /api 밑에 만들어야 했던 부분을 route.js로 통일
    - 파일안에서 GET, HEAD, POST, PUT, DELETE, PATCH, OPTIONS 함수를 통해 메서드에 맞는 API 구현
    - 해당 파일이 존재하는 폴더에서는 page.jsx 존재 불가  |  |

## 리액트 서버 컴포넌트

### 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 기존 구조의 서버 사이드
    - 서버에서 DOM 생성 → 클라이언트에서 하이드레이션 → 브라우저에서 핸들러 DOM 추가 → 상황에 따라 렌더링 트리 변경
- 이 구조의 한계점
    - 자바스크립트 번들 크기가 큼
    - 백엔드 리소스 접근 불가
    - 자동 코드 분할 불가
    - 연쇄적으로 발생하는 클라이언트와 서버의 요청 대응이 어려움
        - 하나의 요청 후 다음 컴포넌트 렌더링이 순차적으로 일어나는 경우
        - 이에 대한 지연을 서버에서 처리의 이점
    - 추상화에 대한 비용 증가
        - 리액트는 템플릿 언어는 아님

### 서버 컴포넌트란?

- 서버에서 할 수 있는 렌더링을 서버에서 동작하도록 하는 컴포넌트
- 서버 컴포넌트 클라이언트 컴포넌트를 import할 수 있지만 `클라이언트 컴포넌트는 서버 컴포넌트 import가 불가하다.`
- 각 컴포넌트의 제약 사항
    - 서버
        - 요청이 오면 딱 한번 실행되는 컴포넌트이기 때문에 상태를 가지지 않음
        - useState, useReducer 등의 훅 사용 불가
        - 렌더링 생명주기 훅인 useEffect 등도 사용 불가
        - 하지만 서버 기능만 제공하는 훅은 사용 가능
        - DOM API 접근 불가
        - DB, 내부 서비스, 파일 시스템 등 서버 자원 asyn/await 접근 가능, 컴포넌트가 async 가능
        - 다른 서버 컴포넌트, HTML(div, span…) 엘리먼트, 클라이언트 컴포넌트 렌더링 가능
    - 클라이언트
        - ‘use client’
        - 서버 컴포넌트, 서버 전용 훅등은 불가능
        - 서버 컴포넌트의 자식 컴포넌트는 가능
        - 그외에는 기존에 사용하던 리액트 컴포넌트이기 때문에 기존에 사용하던 모든 것이 가능
    - 공용 컴포넌트
        - 서버와 클라이언트에서 모두 사용 가능
        - 그런 만큼 양쪽의 제약을 모두 지켜야 함
- 리액트가 서버/클라이언트/공용 컴포넌트를 판단하는법
    - 리액트가 하는 것이 아님
    - 번들러가 지원해야 함
    - 리액트 팀에서 react-server-dom-webpack을 만들었고 Next.js에서 서버 컴포넌트를 협업하여 구현하고 있음

### Next.js에서의 리액트 서버 컴포넌트

- 새로운 fetch
    - getServerSideProps, getStaticProps, getInitialProps 삭제
    - ReactQuery와 같이 캐시 기능
- 정적 렌더링 동적 렌더링
    - 기본으로 빌드 타임에 렌더링 후 캐싱
    - generateStaticParams를 사용하여 특정 주소 기반 캐싱
- 캐시와 mutating 그리고 revalidating
    - revalidate
        1. 캐시된 데이터
        2. 캐시된 데이터는 revalidate 시간까지 유지(새로운 데이터 가져오기전까지)
        3. 시간이 되면 백그라운드에서 데이터를 가져옴
        4. 3번이 완료되면 캐시를 갱신
- 스트리밍
    - 이전에는 요청받은 페이지를 모두 렌더링하여 내려주기 때문에 그 사이 사용자는 아무것도 볼 수 없었음
    - 서버 컴포넌트, loading 컴포넌트를 통해 부분적으로 스트리밍하여 사용자에게 로딩되는 화면을 보여줄 수 있음

### 터보팩

- Rust로 개발된 번들러
- 웹팩보다 최대 700배 빠르다고 ..

### 서버 액션

- form action등을 Next.js 서버에서 해주는 기능
- 페이지가 갱신되지 않고 실행되어 사용자 경험을 올림

</aside>